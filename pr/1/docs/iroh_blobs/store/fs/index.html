<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="redb backed storage"><title>iroh_blobs::store::fs - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-b21aa549bf6d91ff.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="iroh_blobs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0-nightly (c987ad527 2024-05-01)" data-channel="nightly" data-search-js="search-bf21c90c8c1d92b1.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-e32f0c247825364d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-09095024cf37855e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../iroh_blobs/index.html">iroh_blobs</a><span class="version">0.27.0</span></h2></div><h2 class="location"><a href="#">Module fs</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In iroh_blobs::store</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../iroh_blobs/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Type ‘S’ or ‘/’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">iroh_blobs</a>::<wbr><a href="../index.html">store</a>::<wbr><a class="mod" href="#">fs</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/iroh_blobs/store/fs.rs.html#1-2612">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>redb backed storage</p>
<p>Data can get into the store in two ways:</p>
<ol>
<li>import from local data</li>
<li>sync from a remote</li>
</ol>
<p>These two cases are very different. In the first case, we have the data
completely and don’t know the hash yet. We compute the outboard and hash,
and only then move/reference the data into the store.</p>
<p>The entry for the hash comes into existence already complete.</p>
<p>In the second case, we know the hash, but don’t have the data yet. We create
a partial entry, and then request the data from the remote. This is the more
complex case.</p>
<p>Partial entries always start as pure in memory entries without a database
entry. Only once we receive enough data, we convert them into a persistent
partial entry. This is necessary because we can’t trust the size given
by the remote side before receiving data. It is also an optimization,
because for small blobs it is not worth it to create a partial entry.</p>
<p>A persistent partial entry is always stored as three files in the file
system: The data file, the outboard file, and a sizes file that contains
the most up to date information about the size of the data.</p>
<p>The redb database entry for a persistent partial entry does not contain
any information about the size of the data until the size is exactly known.</p>
<p>Updating this information on each write would be too costly.</p>
<p>Marking a partial entry as complete is done from the outside. At this point
the size is taken as validated. Depending on the size we decide whether to
store data and outboard inline or to keep storing it in external files.</p>
<p>Data can get out of the store in two ways:</p>
<ol>
<li>
<p>the data and outboard of both partial and complete entries can be read at any time and
shared over the network. Only data that is complete will be shared, everything else will
lead to validation errors.</p>
</li>
<li>
<p>entries can be exported to the file system. This currently only works for complete entries.</p>
</li>
</ol>
<p>Tables:</p>
<p>The blobs table contains a mapping from hash to rough entry state.
The inline_data table contains the actual data for complete entries.
The inline_outboard table contains the actual outboard for complete entries.
The tags table contains a mapping from tag to hash.</p>
<p>Design:</p>
<p>The redb store is accessed in a single threaded way by an actor that runs
on its own std thread. Communication with this actor is via a flume channel,
with oneshot channels for the return values if needed.</p>
<p>Errors:</p>
<p>ActorError is an enum containing errors that can happen inside message
handlers of the actor. This includes various redb related errors and io
errors when reading or writing non-inlined data or outboard files.</p>
<p>OuterError is an enum containing all the actor errors and in addition
errors when communicating with the actor.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BatchOptions.html" title="struct iroh_blobs::store::fs::BatchOptions">BatchOptions</a></div><div class="desc docblock-short">Options for transaction batching.</div></li><li><div class="item-name"><a class="struct" href="struct.InlineOptions.html" title="struct iroh_blobs::store::fs::InlineOptions">InlineOptions</a></div><div class="desc docblock-short">Options for inlining small complete data or outboards.</div></li><li><div class="item-name"><a class="struct" href="struct.Options.html" title="struct iroh_blobs::store::fs::Options">Options</a></div><div class="desc docblock-short">Options for the file store.</div></li><li><div class="item-name"><a class="struct" href="struct.PathOptions.html" title="struct iroh_blobs::store::fs::PathOptions">PathOptions</a></div><div class="desc docblock-short">Options for directories used by the file store.</div></li><li><div class="item-name"><a class="struct" href="struct.Store.html" title="struct iroh_blobs::store::fs::Store">Store</a></div><div class="desc docblock-short">Storage that is using a redb database for small files and files for
large files.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Entry.html" title="type iroh_blobs::store::fs::Entry">Entry</a></div><div class="desc docblock-short">Use BaoFileHandle as the entry type for the map.</div></li></ul></section></div></main></body></html>