<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Protocol for transferring content-addressed blobs and collections over quic connections. This can be used either with normal quic connections when using the quinn crate or with magicsock connections when using the iroh-net crate."><title>iroh_blobs::protocol - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-b21aa549bf6d91ff.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="iroh_blobs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0-nightly (c987ad527 2024-05-01)" data-channel="nightly" data-search-js="search-bf21c90c8c1d92b1.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-e32f0c247825364d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-09095024cf37855e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../iroh_blobs/index.html">iroh_blobs</a><span class="version">0.27.0</span></h2></div><h2 class="location"><a href="#">Module protocol</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li></ul></section><h2><a href="../index.html">In crate iroh_blobs</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../iroh_blobs/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Type ‘S’ or ‘/’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">iroh_blobs</a>::<wbr><a class="mod" href="#">protocol</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/iroh_blobs/protocol.rs.html#1-516">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Protocol for transferring content-addressed blobs and collections over quic
connections. This can be used either with normal quic connections when using
the <a href="https://crates.io/crates/quinn">quinn</a> crate or with magicsock connections
when using the <a href="https://crates.io/crates/iroh-net">iroh-net</a> crate.</p>
<h2 id="participants"><a class="doc-anchor" href="#participants">§</a>Participants</h2>
<p>The protocol is a request/response protocol with two parties, a <em>provider</em> that
serves blobs and a <em>getter</em> that requests blobs.</p>
<h2 id="goals"><a class="doc-anchor" href="#goals">§</a>Goals</h2>
<ul>
<li>
<p>Be paranoid about data integrity.</p>
<p>Data integrity is considered more important than performance. Data will be validated both on
the provider and getter side. A well behaved provider will never send invalid data. Responses
to range requests contain sufficient information to validate the data.</p>
<p>Note: Validation using blake3 is extremely fast, so in almost all scenarios the validation
will not be the bottleneck even if we validate both on the provider and getter side.</p>
</li>
<li>
<p>Do not limit the size of blobs or collections.</p>
<p>Blobs can be of arbitrary size, up to terabytes. Likewise, collections can contain an
arbitrary number of links. A well behaved implementation will not require the entire blob or
collection to be in memory at once.</p>
</li>
<li>
<p>Be efficient when transferring large blobs, including range requests.</p>
<p>It is possible to request entire blobs or ranges of blobs, where the minimum granularity is a
chunk group of 16KiB or 16 blake3 chunks. The worst case overhead when doing range requests
is about two chunk groups per range.</p>
</li>
<li>
<p>Be efficient when transferring multiple tiny blobs.</p>
<p>For tiny blobs the overhead of sending the blob hashes and the round-trip time for each blob
would be prohibitive.</p>
</li>
</ul>
<p>To avoid roundtrips, the protocol allows grouping multiple blobs into <em>collections</em>.
The semantic meaning of a collection is up to the application. For the purpose
of this protocol, a collection is just a grouping of related blobs.</p>
<h2 id="non-goals"><a class="doc-anchor" href="#non-goals">§</a>Non-goals</h2>
<ul>
<li>
<p>Do not attempt to be generic in terms of the used hash function.</p>
<p>The protocol makes extensive use of the <a href="https://crates.io/crates/blake3">blake3</a> hash
function and it’s special properties such as blake3 verified streaming.</p>
</li>
<li>
<p>Do not support graph traversal.</p>
<p>The protocol only supports collections that directly contain blobs. If you have deeply nested
graph data, you will need to either do multiple requests or flatten the graph into a single
temporary collection.</p>
</li>
<li>
<p>Do not support discovery.</p>
<p>The protocol does not yet have a discovery mechanism for asking the provider what ranges are
available for a given blob. Currently you have to have some out-of-band knowledge about what
node has data for a given hash, or you can just try to retrieve the data and see if it is
available.</p>
</li>
</ul>
<p>A discovery protocol is planned in the future though.</p>
<h2 id="requests"><a class="doc-anchor" href="#requests">§</a>Requests</h2><h3 id="getter-defined-requests"><a class="doc-anchor" href="#getter-defined-requests">§</a>Getter defined requests</h3>
<p>In this case the getter knows the hash of the blob it wants to retrieve and
whether it wants to retrieve a single blob or a collection.</p>
<p>The getter needs to define exactly what it wants to retrieve and send the
request to the provider.</p>
<p>The provider will then respond with the bao encoded bytes for the requested
data and then close the connection. It will immediately close the connection
in case some data is not available or invalid.</p>
<h3 id="provider-defined-requests"><a class="doc-anchor" href="#provider-defined-requests">§</a>Provider defined requests</h3>
<p>In this case the getter sends a blob to the provider. This blob can contain
some kind of query. The exact details of the query are up to the application.</p>
<p>The provider evaluates the query and responds with a serialized request in
the same format as the getter defined requests, followed by the bao encoded
data. From then on the protocol is the same as for getter defined requests.</p>
<h3 id="specifying-the-required-data"><a class="doc-anchor" href="#specifying-the-required-data">§</a>Specifying the required data</h3>
<p>A <a href="struct.GetRequest.html" title="struct iroh_blobs::protocol::GetRequest"><code>GetRequest</code></a> contains a hash and a specification of what data related to
that hash is required. The specification is using a <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a> which
has a compact representation on the wire but is otherwise identical to a
sequence of sets of ranges.</p>
<p>In the following, we describe how the <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a> is to be created for
different common scenarios.</p>
<p>Ranges are always given in terms of 1024 byte blake3 chunks, <em>not</em> in terms
of bytes or chunk groups. The reason for this is that chunks are the fundamental
unit of hashing in blake3. Addressing anything smaller than a chunk is not
possible, and combining multiple chunks is merely an optimization to reduce
metadata overhead.</p>
<h4 id="individual-blobs"><a class="doc-anchor" href="#individual-blobs">§</a>Individual blobs</h4>
<p>In the easiest case, the getter just wants to retrieve a single blob. In this
case, the getter specifies <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a> that contains a single element.
This element is the set of all chunks to indicate that we
want the entire blob, no matter how many chunks it has.</p>
<p>Since this is a very common case, there is a convenience method
<a href="struct.GetRequest.html#method.single" title="associated function iroh_blobs::protocol::GetRequest::single"><code>GetRequest::single</code></a> that only requires the hash of the blob.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>request = GetRequest::single(hash);</code></pre></div>
<h4 id="ranges-of-blobs"><a class="doc-anchor" href="#ranges-of-blobs">§</a>Ranges of blobs</h4>
<p>In this case, we have a (possibly large) blob and we want to retrieve only
some ranges of chunks. This is useful in similar cases as HTTP range requests.</p>
<p>We still need just a single element in the <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a>, since we are
still only interested in a single blob. However, this element contains all
the chunk ranges we want to retrieve.</p>
<p>For example, if we want to retrieve chunks 0-10 of a blob, we would
create a <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a> like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>spec = RangeSpecSeq::from_ranges([ChunkRanges::from(..ChunkNum(<span class="number">10</span>))]);
<span class="kw">let </span>request = GetRequest::new(hash, spec);</code></pre></div>
<p>Here <code>ChunkNum</code> is a newtype wrapper around <code>u64</code> that is used to indicate
that we are talking about chunk numbers, not bytes.</p>
<p>While not that common, it is also possible to request multiple ranges of a
single blob. For example, if we want to retrieve chunks <code>0-10</code> and <code>100-110</code>
of a large file, we would create a <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a> like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ranges = <span class="kw-2">&amp;</span>ChunkRanges::from(..ChunkNum(<span class="number">10</span>)) | <span class="kw-2">&amp;</span>ChunkRanges::from(ChunkNum(<span class="number">100</span>)..ChunkNum(<span class="number">110</span>));
<span class="kw">let </span>spec = RangeSpecSeq::from_ranges([ranges]);
<span class="kw">let </span>request = GetRequest::new(hash, spec);</code></pre></div>
<p>To specify chunk ranges, we use the [<code>ChunkRanges</code>] type alias.
This is actually the <a href="range_collections::range_set::RangeSet"><code>RangeSet</code></a> type from the
<a href="https://crates.io/crates/range_collections">range_collections</a> crate. This
type supports efficient boolean operations on sets of non-overlapping ranges.</p>
<p>The <a href="range_collections::range_set::RangeSet2"><code>RangeSet2</code></a> type is a type alias for <a href="range_collections::range_set::RangeSet"><code>RangeSet</code></a> that can store up to
2 boundaries without allocating. This is sufficient for most use cases.</p>
<h4 id="collections"><a class="doc-anchor" href="#collections">§</a>Collections</h4>
<p>In this case the provider has a collection that contains multiple blobs.
We want to retrieve all blobs in the collection.</p>
<p>When used for collections, the first element of a <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a> refers
to the collection itself, and all subsequent elements refer to the blobs
in the collection. When a <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a> specifies ranges for more than
one blob, the provider will interpret this as a request for a collection.</p>
<p>One thing to note is that we might not yet know how many blobs are in the
collection. Therefore, it is not possible to download an entire collection
by just specifying [<code>ChunkRanges::all()</code>] for all children.</p>
<p>Instead, <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a> allows defining infinite sequences of range sets.
The <a href="struct.RangeSpecSeq.html#method.all" title="associated function iroh_blobs::protocol::RangeSpecSeq::all"><code>RangeSpecSeq::all()</code></a> method returns a <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a> that, when iterated
over, will yield [<code>ChunkRanges::all()</code>] forever.</p>
<p>So specifying a collection would work like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>spec = RangeSpecSeq::all();
<span class="kw">let </span>request = GetRequest::new(hash, spec);</code></pre></div>
<p>Downloading an entire collection is also a very common case, so there is a
convenience method <a href="struct.GetRequest.html#method.all" title="associated function iroh_blobs::protocol::GetRequest::all"><code>GetRequest::all</code></a> that only requires the hash of the
collection.</p>
<h4 id="parts-of-collections"><a class="doc-anchor" href="#parts-of-collections">§</a>Parts of collections</h4>
<p>The most complex common case is when we have retrieved a collection and
it’s children, but were interrupted before we could retrieve all children.</p>
<p>In this case we need to specify the collection we want to retrieve, but
exclude the children and parts of children that we already have.</p>
<p>For example, if we have a collection with 3 children, and we already have
the first child and the first 1000000 chunks of the second child.</p>
<p>We would create a <a href="struct.GetRequest.html" title="struct iroh_blobs::protocol::GetRequest"><code>GetRequest</code></a> like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>spec = RangeSpecSeq::from_ranges([
  ChunkRanges::empty(), <span class="comment">// we don't need the collection itself
  </span>ChunkRanges::empty(), <span class="comment">// we don't need the first child either
  </span>ChunkRanges::from(ChunkNum(<span class="number">1000000</span>)..), <span class="comment">// we need the second child from chunk 1000000 onwards
  </span>ChunkRanges::all(), <span class="comment">// we need the third child completely
</span>]);
<span class="kw">let </span>request = GetRequest::new(hash, spec);</code></pre></div>
<h4 id="requesting-chunks-for-each-child"><a class="doc-anchor" href="#requesting-chunks-for-each-child">§</a>Requesting chunks for each child</h4>
<p>The RangeSpecSeq allows some scenarios that are not covered above. E.g. you
might want to request a collection and the first chunk of each child blob to
do something like mime type detection.</p>
<p>You do not know how many children the collection has, so you need to use
an infinite sequence.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>spec = RangeSpecSeq::from_ranges_infinite([
  ChunkRanges::all(), <span class="comment">// the collection itself
  </span>ChunkRanges::from(..ChunkNum(<span class="number">1</span>)), <span class="comment">// the first chunk of each child
</span>]);
<span class="kw">let </span>request = GetRequest::new(hash, spec);</code></pre></div>
<h4 id="requesting-a-single-child"><a class="doc-anchor" href="#requesting-a-single-child">§</a>Requesting a single child</h4>
<p>It is of course possible to request a single child of a collection. E.g.
the following would download the second child of a collection:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>spec = RangeSpecSeq::from_ranges([
  ChunkRanges::empty(), <span class="comment">// we don't need the collection itself
  </span>ChunkRanges::empty(), <span class="comment">// we don't need the first child either
  </span>ChunkRanges::all(), <span class="comment">// we need the second child completely
</span>]);
<span class="kw">let </span>request = GetRequest::new(hash, spec);</code></pre></div>
<p>However, if you already have the collection, you might as well locally
look up the hash of the child and request it directly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>request = GetRequest::single(child_hash);</code></pre></div>
<h4 id="why-rangespec-and-rangespecseq"><a class="doc-anchor" href="#why-rangespec-and-rangespecseq">§</a>Why RangeSpec and RangeSpecSeq?</h4>
<p>You might wonder why we have <a href="struct.RangeSpec.html" title="struct iroh_blobs::protocol::RangeSpec"><code>RangeSpec</code></a> and <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a>, when a simple
sequence of [<code>ChunkRanges</code>] might also do.</p>
<p>The <a href="struct.RangeSpec.html" title="struct iroh_blobs::protocol::RangeSpec"><code>RangeSpec</code></a> and <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a> types exist to provide an efficient
representation of the request on the wire. In the <a href="struct.RangeSpec.html" title="struct iroh_blobs::protocol::RangeSpec"><code>RangeSpec</code></a> type,
sequences of ranges are encoded alternating intervals of selected and
non-selected chunks. This results in smaller numbers that will result in fewer bytes
on the wire when using the <a href="https://crates.io/crates/postcard">postcard</a> encoding
format that uses variable length integers.</p>
<p>Likewise, the <a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a> type is a sequence of <a href="struct.RangeSpec.html" title="struct iroh_blobs::protocol::RangeSpec"><code>RangeSpec</code></a>s that
does run length encoding to remove repeating elements. It also allows infinite
sequences of <a href="struct.RangeSpec.html" title="struct iroh_blobs::protocol::RangeSpec"><code>RangeSpec</code></a>s to be encoded, unlike a simple sequence of
[<code>ChunkRanges</code>]s.</p>
<p><a href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq"><code>RangeSpecSeq</code></a> should be efficient even in case of very fragmented availability
of chunks, like a download from multiple providers that was frequently interrupted.</p>
<h2 id="responses"><a class="doc-anchor" href="#responses">§</a>Responses</h2>
<p>The response stream contains the bao encoded bytes for the requested data.
The data will be sent in the order in which it was requested, so ascending
chunks for each blob, and blobs in the order in which they appear in the
collection.</p>
<p>For details on the bao encoding, see the <a href="https://github.com/oconnor663/bao/blob/master/docs/spec.md">bao specification</a>
and the <a href="https://crates.io/crates/bao-tree">bao-tree</a> crate. The bao-tree crate
is identical to the bao crate, except that it allows combining multiple blake3
chunks to chunk groups for efficiency.</p>
<p>As a consequence of the chunk group optimization, chunk ranges in the response
will be rounded up to chunk groups ranges, so e.g. if you ask for chunks 0..10,
you will get chunks 0-16. This is done to reduce metadata overhead, and might
change in the future.</p>
<p>For a complete response, the chunks are guaranteed to completely cover the
requested ranges.</p>
<p>Reasons for not retrieving a complete response are two-fold:</p>
<ul>
<li>
<p>the connection to the provider was interrupted, or the provider encountered
an internal error. In this case the provider will close the entire quinn connection.</p>
</li>
<li>
<p>the provider does not have the requested data, or discovered on send that the
requested data is not valid.</p>
</li>
</ul>
<p>In this case the provider will close just the stream used to send the response.
The exact location of the missing data can be retrieved from the error.</p>
<h2 id="requesting-multiple-unrelated-blobs"><a class="doc-anchor" href="#requesting-multiple-unrelated-blobs">§</a>Requesting multiple unrelated blobs</h2>
<p>Currently, the protocol does not support requesting multiple unrelated blobs
in a single request. As an alternative, you can create a collection
on the provider side and use that to efficiently retrieve the blobs.</p>
<p>If that is not possible, you can create a custom request handler that
accepts a custom request struct that contains the hashes of the blobs.</p>
<p>If neither of these options are possible, you have no choice but to do
multiple requests. However, note that multiple requests will be multiplexed
over a single connection, and the overhead of a new QUIC stream on an existing
connection is very low.</p>
<p>In case nodes are permanently exchanging data, it is probably valuable to
keep a connection open and reuse it for multiple requests.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.GetRequest.html" title="struct iroh_blobs::protocol::GetRequest">GetRequest</a></div><div class="desc docblock-short">A request</div></li><li><div class="item-name"><a class="struct" href="struct.NonEmptyRequestRangeSpecIter.html" title="struct iroh_blobs::protocol::NonEmptyRequestRangeSpecIter">NonEmptyRequestRangeSpecIter</a></div><div class="desc docblock-short">An iterator over blobs in the sequence with a non-empty range specs.</div></li><li><div class="item-name"><a class="struct" href="struct.RangeSpec.html" title="struct iroh_blobs::protocol::RangeSpec">RangeSpec</a></div><div class="desc docblock-short">A chunk range specification as a sequence of chunk offsets.</div></li><li><div class="item-name"><a class="struct" href="struct.RangeSpecSeq.html" title="struct iroh_blobs::protocol::RangeSpecSeq">RangeSpecSeq</a></div><div class="desc docblock-short">A chunk range specification for a sequence of blobs.</div></li><li><div class="item-name"><a class="struct" href="struct.UnknownErrorCode.html" title="struct iroh_blobs::protocol::UnknownErrorCode">UnknownErrorCode</a></div><div class="desc docblock-short">Unknown error_code, can not be converted into <a href="enum.Closed.html" title="enum iroh_blobs::protocol::Closed"><code>Closed</code></a>.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Closed.html" title="enum iroh_blobs::protocol::Closed">Closed</a></div><div class="desc docblock-short">Reasons to close connections or stop streams.</div></li><li><div class="item-name"><a class="enum" href="enum.Request.html" title="enum iroh_blobs::protocol::Request">Request</a></div><div class="desc docblock-short">A request to the provider</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.ALPN.html" title="constant iroh_blobs::protocol::ALPN">ALPN</a></div><div class="desc docblock-short">The ALPN used with quic for the iroh bytes protocol.</div></li><li><div class="item-name"><a class="constant" href="constant.MAX_MESSAGE_SIZE.html" title="constant iroh_blobs::protocol::MAX_MESSAGE_SIZE">MAX_MESSAGE_SIZE</a></div><div class="desc docblock-short">Maximum message size is limited to 100MiB for now.</div></li></ul></section></div></main></body></html>